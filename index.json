[{"content":"https://github.com/bazelbuild/examples https://bazel.build/faq.html\nbazelとは ソースコードをコンパイルして、実行可能形式にしたり、テストをしたりする一連の処理をまとめてやってくれるツールのことをビルドツールと言い、例えばMake,Maven, Gradleなどがある。 もともとgoogle ではBlazeというビルドツールが利用されていて、これをOSS化したのがbazelになる\nbazelの特徴   多言語サポート\n Bazelは多くの言語をサポートしており、任意のプログラミング言語をサポートするように拡張可能。    高レベルのビルド言語\n プロジェクトはBUILDファイルにてで記述。BUILDファイル相互接続された小さなライブラリ、バイナリ、およびテストのセットとしてプロジェクトを記述する簡潔なテキスト形式。対照的に、Makeのようなツールでは、個々のファイルとコンパイラの呼び出しを記述する必要があります。    マルチプラットフォームのサポート\n 同じツールと同じBUILDファイルを使用して、さまざまなアーキテクチャ、さらにはさまざまなプラットフォーム用のソフトウェアを構築可能 GoogleではBazelを使用してデータセンターのシステムで実行されるサーバーアプリケーションから携帯電話で実行されるクライアントアプリまで、あらゆるものを構築。    再現性\n BUILDファイルでは、各ライブラリ、テスト、およびバイナリで直接の依存関係を完全に指定する必要があるため、Bazelはこの依存関係情報を使用して、ソースファイルに変更を加えたときに何を再構築する必要があるか、およびどのタスクを並行して実行できるかを認識。 これはすべてのビルドが常に同じ結果を生成することを意味します。    スケーラブル\n Bazelは大規模なビルドを処理可能。 Googleでは、サーバーバイナリに10万のソースファイルがあるのが一般的であり、ファイルが変更されていないビルドには約200ミリ秒かかかるらしい    Googleはなぜbazelを利用するのか  Makeの場合  人力でMakefileを書くのは結構辛い   Mavenの場合  Javaだけなのが辛い Bazelではコードを再利用可能な単位に細分化することを推奨しており、差分だけをビルドするといったことが可能なので   gradleの場合  Gradleの設定ファイルが読みづらいのが辛い Bazelは各アクションが何を行うかを正確に理解できるのでより並列化され、より再現性が高くなるらしい    gradle 陣営はbazelを使うとBUILDファイルがめちゃくちゃ増えることなどで管理コストが増大することを理由に反論している。 参考: https://blog.gradle.org/gradle-vs-bazel-jvm\n実際にどのような会社やOSSがbazelを使用しているのか https://bazel.build/users.html に書いてあるが気になった部分を書く\n 日本企業が少ない。  2022/01/15現在、LINEだけしかない。まだまだ日本でbazelが受けいられ邸内状態かなと思っている   KubernetesはBazelビルドから脱却した  どうやらKubernetesではビルドが煩雑で大変だったのをmakeに統一したようです。 https://github.com/kubernetes/enhancements/issues/2420 https://github.com/kubernetes/kubernetes/issues/88553 基本ほとんどがGoで書かれているので、まあbazelのおいしさを完全に享受できるとは思わないです。    インストール方法 自分はMacを使用したのでMacでの説明になります 参考: https://docs.bazel.build/versions/4.2.2/install-os-x.html\nexport BAZEL_VERSION=3.2.0 curl -fLO \u0026#34;https://github.com/bazelbuild/bazel/releases/download/${BAZEL_VERSION}/bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh\u0026#34; # 実行権限をつけて実行 chmod +x \u0026#34;bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh\u0026#34; ./bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh --user user@usernoMacBook-Pro tmp % ./bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh --user Bazel installer --------------- Bazel is bundled with software licensed under the GPLv2 with Classpath exception. You can find the sources next to the installer on our release page: https://github.com/bazelbuild/bazel/releases # setting authenticate proxy # Binary package at HEAD (@15371720ae0c4) - [Commit](https://github.com/bazelbuild/bazel/commit/15371720ae0c4) Uncompressing......Extracting Bazel installation... . Bazel is now installed! Make sure you have \u0026quot;/Users/user/bin\u0026quot; in your path. For bash completion, add the following line to your : source /Users/user/.bazel/bin/bazel-complete.bash For fish shell completion, link this file into your /Users/user/.config/fish/completions/ directory: ln -s /Users/user/.bazel/bin/bazel.fish /Users/user/.config/fish/completions/bazel.fish See http://bazel.build/docs/getting-started.html to start a new project! bazelの始め方  WORKSPACEファイルの用意  bazelにおけるワークスペースとは、ビルドするソフトウェアのソースファイルとビルド出力先を含むディレクトリ.各ワークスペースごとにはWORKSPACEというテキストファイルがあり、空も場合もあれば、外部依存関係への参照が含まれている. つまりプロジェクトのルートにはWORKSPACEがあればOK   BUILDファイルの用意  Starlarkという言語を利用して、ビルドターゲットを指定することでBUILDファイルを記述.  java_binary( name = \u0026quot;ProjectRunner\u0026quot;, srcs = [\u0026quot;src/main/java/com/example/ProjectRunner.java\u0026quot;], main_class = \u0026quot;com.example.ProjectRunner\u0026quot;, deps = [\u0026quot;:greeter\u0026quot;], ) java_library( name = \u0026quot;greeter\u0026quot;, srcs = [\u0026quot;src/main/java/com/example/Greeting.java\u0026quot;], )  Bazelがビルドするソースコードとその依存関係、そしてbazelが利用するビルドルールなどが記載される   ビルドする  bazel build //path/to/package:\u0026lt;ビルドターゲット名\u0026gt;でビルド可能  user@usernoMacBook-Pro java-tutorial % bazel build //:ProjectRunner INFO: Analyzed target //:ProjectRunner (0 packages loaded, 0 targets configured). INFO: Found 1 target... Target //:ProjectRunner up-to-date: bazel-bin/ProjectRunner.jar bazel-bin/ProjectRunner INFO: Elapsed time: 0.431s, Critical Path: 0.01s INFO: 1 process: 1 internal. INFO: Build completed successfully, 1 total action   サンプルプロジェクトの解説 対象プロジェクトは https://github.com/bazelbuild/examples/tree/main/java-tutorial\nワークスペースの立ち上げ BUILD ファイルの理解 java_binary( name = \u0026#34;ProjectRunner\u0026#34;, srcs = glob([\u0026#34;src/main/java/com/example/*.java\u0026#34;]), ) プロジェクトのビルド $ bazel build //:ProjectRunner 依存関係のグラフを出力 このコマンドを実行すること\nbazel query --notool_deps --noimplicit_deps \u0026quot;deps(//:ProjectRunner)\u0026quot; --output graph http://www.webgraphviz.com/ ここで確認する\nbazelビルドを改良する load(\u0026#34;@rules_java//java:defs.bzl\u0026#34;, \u0026#34;java_binary\u0026#34;) java_binary( name = \u0026#34;ProjectRunner\u0026#34;, srcs = [\u0026#34;src/main/java/com/example/ProjectRunner.java\u0026#34;], main_class = \u0026#34;com.example.ProjectRunner\u0026#34;, deps = [\u0026#34;:greeter\u0026#34;], ) java_library( name = \u0026#34;greeter\u0026#34;, srcs = [\u0026#34;src/main/java/com/example/Greeting.java\u0026#34;], ) bazel build //:ProjectRunner 標準で提供されているビルドルールをみてみよう https://docs.bazel.build/versions/main/be/java.html\n対応言語 https://awesomebazel.com/\nGo言語でBazelを利用する場合 https://note.crohaco.net/2020/bazel-golang/\ngazelleを利用するのが良い。上の参考サイトがDockerコンテナのビルドまで書いてあって参考になる\n考察  システムのポリグロット化やリポジトリのモノリポ化が進んだ際に、bazelの出番。 ビルドする際に各言語やフレームワークの環境設定をしなくていいのはとても便利だと思う 参考文献が少なく非常に学習コストが低い。 特にDocker周りは、既存のやり方とかなり異なるので、難易度が高い  ","permalink":"https://lottotto.github.io/blog/posts/bazel/","summary":"https://github.com/bazelbuild/examples https://bazel.build/faq.html\nbazelとは ソースコードをコンパイルして、実行可能形式にしたり、テストをしたりする一連の処理をまとめてやってくれるツールのことをビルドツールと言い、例えばMake,Maven, Gradleなどがある。 もともとgoogle ではBlazeというビルドツールが利用されていて、これをOSS化したのがbazelになる\nbazelの特徴   多言語サポート\n Bazelは多くの言語をサポートしており、任意のプログラミング言語をサポートするように拡張可能。    高レベルのビルド言語\n プロジェクトはBUILDファイルにてで記述。BUILDファイル相互接続された小さなライブラリ、バイナリ、およびテストのセットとしてプロジェクトを記述する簡潔なテキスト形式。対照的に、Makeのようなツールでは、個々のファイルとコンパイラの呼び出しを記述する必要があります。    マルチプラットフォームのサポート\n 同じツールと同じBUILDファイルを使用して、さまざまなアーキテクチャ、さらにはさまざまなプラットフォーム用のソフトウェアを構築可能 GoogleではBazelを使用してデータセンターのシステムで実行されるサーバーアプリケーションから携帯電話で実行されるクライアントアプリまで、あらゆるものを構築。    再現性\n BUILDファイルでは、各ライブラリ、テスト、およびバイナリで直接の依存関係を完全に指定する必要があるため、Bazelはこの依存関係情報を使用して、ソースファイルに変更を加えたときに何を再構築する必要があるか、およびどのタスクを並行して実行できるかを認識。 これはすべてのビルドが常に同じ結果を生成することを意味します。    スケーラブル\n Bazelは大規模なビルドを処理可能。 Googleでは、サーバーバイナリに10万のソースファイルがあるのが一般的であり、ファイルが変更されていないビルドには約200ミリ秒かかかるらしい    Googleはなぜbazelを利用するのか  Makeの場合  人力でMakefileを書くのは結構辛い   Mavenの場合  Javaだけなのが辛い Bazelではコードを再利用可能な単位に細分化することを推奨しており、差分だけをビルドするといったことが可能なので   gradleの場合  Gradleの設定ファイルが読みづらいのが辛い Bazelは各アクションが何を行うかを正確に理解できるのでより並列化され、より再現性が高くなるらしい    gradle 陣営はbazelを使うとBUILDファイルがめちゃくちゃ増えることなどで管理コストが増大することを理由に反論している。 参考: https://blog.gradle.org/gradle-vs-bazel-jvm\n実際にどのような会社やOSSがbazelを使用しているのか https://bazel.build/users.html に書いてあるが気になった部分を書く","title":"bazel触ってみた"}]