[{"content":"モチベーション Go言語のOpentelemetryで適当なアプリにトレーシング機能をInstrumentation（計装）した際に、分割して色々なものは対応していたのだが、まとめてやってみたというものがなく、結構苦戦したので忘備録がてら残しておこうと思う。ソースコード全量はGithubにPushしているので面倒な解説はいらねえ！という人はこちらをみてください。 https://github.com/lottotto/gRPC-Database-sample-app/tree/7f4d8f91d0c5d5a675d49e18a058c470d9b34973\nトレースしたいシステム クライアントからgRPC GateWayにhttpで送られたものがgRPC通信でgRPCサーバに転送。gRPCサーバがPostgresにSQLを実行する流れを確認したい。ただしフォーカスとしてはgRPC GateWayからとする。 クライアントからは/に対してbodyに{\u0026quot;name\u0026quot;: message} の形式のJSONをPostすることで、データベースにその内容がINSERTされる。またクエリパラメータにそのnameを付与してGETで送ることで、そのnameを持つ行全てを戻す。\n実装のポイント クライアント側 標準ライブラリを用いたhttpサーバの構成方法は他の記事に譲るとして、、、\n TraceProviderの追加  TracerProvider provides access to instrumentation Tracers. TracerProviderとはTracerへのアクセスを提供する。TracerとはStartメソッドを持つInterfaceであり、contextとNameを引数にSpanとContextを作成する機能を持つ。もしこのcontextの中にSpanがあればその子spanとして作成される\n参考:\nhttps://pkg.go.dev/go.opentelemetry.io/otel/trace#TracerProvider https://pkg.go.dev/go.opentelemetry.io/otel/trace#Tracer\nTracerProviderへの追加はプロセスセーフではないといけないので、main関数の中でかくこと。間違ってもhandlerとか多数のスレッドで呼び出されるところでやってはいけない。 後続のサービスへspanのContextを伝播するには、otel.SetTextMapPropagatorを追記すること。これはリクエスト送る側だけではなく、受け取る側にも必要\npackage main import ( \u0026#34;github.com/lottotto/stdgrpc/utils\u0026#34; \u0026#34;go.opentelemetry.io/otel\u0026#34; \u0026#34;go.opentelemetry.io/otel/propagation\u0026#34; ) func main() { // トレースの追加 \ttp, err := utils.InitTraceProviderStdOut(\u0026#34;gRPC\u0026#34;, \u0026#34;1.0.0\u0026#34;) otel.SetTracerProvider(tp) // 後続のサービスにつなげるためにpropagaterを追加 \totel.SetTextMapPropagator( propagation.NewCompositeTextMapPropagator( propagation.TraceContext{}, propagation.Baggage{}, ), ) .... }  gRPCインターセプタの追加  gRPCで後続のサービスにリクエストを送るので、gRPCのインターセプタを利用して、gRPCの情報などをtraceの値に入れる。もちろん後続へspanを教えるためにこのメソッドは必要。 grpc.WithUnaryInterceptorを利用し、opentelemetryのUnary通信用のインターセプタを入れる。複数Interceptorを入れる場合はChain何ちゃらを使うこと。 （おまけ）gRPCのコネクションをプールとして利用する場合は、Controllerなりの構造体を作成し、その中にgRPCのconnectionを入れるのが良い。global変数として使うと、変数定義時に死ぬ。\npackage main import ( ... \u0026#34;go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc\u0026#34; ) type Controller struct { conn *grpc.ClientConn } func main() { ... grpcHost := utils.GetEnv(\u0026#34;GRPC_HOST\u0026#34;, \u0026#34;localhost\u0026#34;) grpcPort := utils.GetEnv(\u0026#34;GRPC_PORT\u0026#34;, \u0026#34;50051\u0026#34;) conn, err := grpc.Dial(grpcHost+\u0026#34;:\u0026#34;+grpcPort, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()), ) defer conn.Close() c := Controller{conn: conn} ... }  (おまけ)otelhttpの利用  今回は標準ライブラリを用いて構築したので、otelhttpを利用する。これを使うことで、spanの作成や終了、メタデータの入れ込みなどを隠蔽できる。これを使う場合はオプションにotelhttp.WithPropagators(otel.GetTextMapPropagator())を追記しないといけない。 ただ実際はなくてもよかった。おそらくhttp送信する際にトレース情報を付与しているので、httpサーバ→httpサーバの場合は必要と思われる。ただし落としておく必要もないと思うのでそのままにする。\npackage main import ( ... ) func (c *Controller) userHandler(w http.ResponseWriter, r *http.Request) { ... } func main() { c := Controller{conn: conn} // otelhttp用のオプションが必要 \totelOptions := []otelhttp.Option{ otelhttp.WithTracerProvider(otel.GetTracerProvider()), otelhttp.WithPropagators(otel.GetTextMapPropagator()), } otelUserHandler := otelhttp.NewHandler( http.HandlerFunc(c.userHandler), \u0026#34;UserHandler\u0026#34;, otelOptions..., ) http.HandleFunc(\u0026#34;/\u0026#34;, otelUserHandler.ServeHTTP) fmt.Println(\u0026#34;start http server\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } サーバ側 gRPCサーバの構成方法は他の記事に譲るとして、、、\n TracerProviderの追加  大事なので2回書きますが、gRPCリクエスト受け取るサーバ側にもotel.SetTextMapPropagatorを追記すること。\npackage main import ( \u0026#34;go.opentelemetry.io/otel\u0026#34; \u0026#34;go.opentelemetry.io/otel/propagation\u0026#34; \u0026#34;github.com/lottotto/stdgrpc/utils\u0026#34; ) func main() { // tracerの設定 \ttp, err := utils.InitTraceProviderStdOut(\u0026#34;gRPC\u0026#34;, \u0026#34;1.0.0\u0026#34;) if err != nil { log.Fatalf(\u0026#34;something error: %v\u0026#34;, err) } otel.SetTracerProvider(tp) // 受け取る側にも必要→超ハマった \totel.SetTextMapPropagator( propagation.NewCompositeTextMapPropagator( propagation.TraceContext{}, propagation.Baggage{}, ), ) ... }  gRPCインターセプタの追加  gRPCクライアント側と同じように、サーバ側もgRPCのUnaryIntercepterにopentelemetry用のインターセプタを入れてあげます。\npackage main import ( ... \u0026#34;go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; ... ) func main (){ lis, err := net.Listen(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;0.0.0.0:%d\u0026#34;, 50051)) if err != nil { log.Fatalf(\u0026#34;failed to listen: %v\u0026#34;, err) } defer lis.Close() s := grpc.NewServer( grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor()), ) ... }  SQL用のinstrumentationライブラリの追加  driverNameを追加し、otelsql用のドライバを作成する。その後そのdriverNameを利用してsqlのコネクションを開く。自分はマッピングの都合上、sqlxを使用した。database/sqlパッケージの互換だが、特にバグは出ずに使えている。本当に使っていいのかはもっと調査しなければならない。 これを追加することで、どのSQLクエリで実行されているかがトレースに出るようになった。ただし、実際のクエリパラメータは個人情報の問題起因で、出さないようにしている。\n(おまけ)こちらもgRPC通信のコネクションのように他プロセスでコネクションを共有し、コネクションプールとして利用するためには、main関数か何かでコネクションを作成、serverごとに構造体のフィールドとして持たせるのがよい。\npackage main import ( ... \u0026#34;github.com/jmoiron/sqlx\u0026#34; _ \u0026#34;github.com/lib/pq\u0026#34; semconv \u0026#34;go.opentelemetry.io/otel/semconv/v1.7.0\u0026#34; \u0026#34;github.com/XSAM/otelsql\u0026#34; ... ) func main(){ ... driverName, err := otelsql.Register(\u0026#34;postgres\u0026#34;, semconv.DBSystemPostgreSQL.Value.AsString()) if err != nil { log.Fatalf(\u0026#34;something error: %v\u0026#34;, err) } conn, err := sqlx.Open(driverName, utils.GetPostgresConnectionInfo()) if err != nil { log.Fatalf(\u0026#34;could not connect db: %v\u0026#34;, err) } defer conn.Close() ... } 結果 上記のような形で、db.statement部分に実行しているSQL文と、db.systemにPostgresという文字列が出力された。他にどのようなパラメータを出すべきかは、Githubにまとまっている。\n参考: https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/database.md#call-level-attributes\nまとめ 結局自分で作り込むところは、TraceProvider部分とインターセプタとSQL接続するときのドライバ部分だけだった。今考えると簡単に実装できるのだと思う。実際の開発現場ではデータベースサーバの持ち主は、インフラを管理している舞台になると思うのでSQLを観れるのは良いと思う。またgRPC通信時にはどのようなトレースの情報を出すべきかについては考えないといけない。\n","permalink":"https://lottotto.github.io/blog/posts/otelsql-grpc/","summary":"モチベーション Go言語のOpentelemetryで適当なアプリにトレーシング機能をInstrumentation（計装）した際に、分割して色々なものは対応していたのだが、まとめてやってみたというものがなく、結構苦戦したので忘備録がてら残しておこうと思う。ソースコード全量はGithubにPushしているので面倒な解説はいらねえ！という人はこちらをみてください。 https://github.com/lottotto/gRPC-Database-sample-app/tree/7f4d8f91d0c5d5a675d49e18a058c470d9b34973\nトレースしたいシステム クライアントからgRPC GateWayにhttpで送られたものがgRPC通信でgRPCサーバに転送。gRPCサーバがPostgresにSQLを実行する流れを確認したい。ただしフォーカスとしてはgRPC GateWayからとする。 クライアントからは/に対してbodyに{\u0026quot;name\u0026quot;: message} の形式のJSONをPostすることで、データベースにその内容がINSERTされる。またクエリパラメータにそのnameを付与してGETで送ることで、そのnameを持つ行全てを戻す。\n実装のポイント クライアント側 標準ライブラリを用いたhttpサーバの構成方法は他の記事に譲るとして、、、\n TraceProviderの追加  TracerProvider provides access to instrumentation Tracers. TracerProviderとはTracerへのアクセスを提供する。TracerとはStartメソッドを持つInterfaceであり、contextとNameを引数にSpanとContextを作成する機能を持つ。もしこのcontextの中にSpanがあればその子spanとして作成される\n参考:\nhttps://pkg.go.dev/go.opentelemetry.io/otel/trace#TracerProvider https://pkg.go.dev/go.opentelemetry.io/otel/trace#Tracer\nTracerProviderへの追加はプロセスセーフではないといけないので、main関数の中でかくこと。間違ってもhandlerとか多数のスレッドで呼び出されるところでやってはいけない。 後続のサービスへspanのContextを伝播するには、otel.SetTextMapPropagatorを追記すること。これはリクエスト送る側だけではなく、受け取る側にも必要\npackage main import ( \u0026#34;github.com/lottotto/stdgrpc/utils\u0026#34; \u0026#34;go.opentelemetry.io/otel\u0026#34; \u0026#34;go.opentelemetry.io/otel/propagation\u0026#34; ) func main() { // トレースの追加 \ttp, err := utils.InitTraceProviderStdOut(\u0026#34;gRPC\u0026#34;, \u0026#34;1.0.0\u0026#34;) otel.SetTracerProvider(tp) // 後続のサービスにつなげるためにpropagaterを追加 \totel.SetTextMapPropagator( propagation.NewCompositeTextMapPropagator( propagation.TraceContext{}, propagation.Baggage{}, ), ) .... }  gRPCインターセプタの追加  gRPCで後続のサービスにリクエストを送るので、gRPCのインターセプタを利用して、gRPCの情報などをtraceの値に入れる。もちろん後続へspanを教えるためにこのメソッドは必要。 grpc.WithUnaryInterceptorを利用し、opentelemetryのUnary通信用のインターセプタを入れる。複数Interceptorを入れる場合はChain何ちゃらを使うこと。 （おまけ）gRPCのコネクションをプールとして利用する場合は、Controllerなりの構造体を作成し、その中にgRPCのconnectionを入れるのが良い。global変数として使うと、変数定義時に死ぬ。\npackage main import ( ... \u0026#34;go.","title":"Opentelemetryで基本的なトレーシングパターンを実装する"},{"content":"モチベーション Goの受け取ったデータを読んだり書いたりうまくできているのは、ReadメソッドとWriteメソッド、そしてどのメソッドを持つ、io.Reader、io.Writerといったインターフェースである。bytes.bufferをお題に色々忘れないようにメモしていく\nbyteとは 1バイトの範囲（1から255）を表すデータ型。 Go言語では、ファイル処理だったり、画像だったり、リクエストだったり色々な面で[]byteが出てくる。 もちろんstringも文字コードで表現されることから2バイトであるので、bytes型のスライスとして表現されることは多い。 []byteとstringの変換は下記の通り\n// []bytes -\u0026gt; string の変換 str := string([]bytes) // string -\u0026gt; []bytesの変換 b := []byte(str) このようにbyte型のスライスは頻出で簡単にstringに変換できる。このbyte型のスライスを色々簡単に操作できるようなパッケージがbytesパッケージになる。詳しくは公式ドキュメント参照。https://pkg.go.dev/byte\nbytesパッケージの中で2つだけ型が宣言されている.bytes.buffer型とreader型である。これをみていく\nbytes.bufferとは bytes.bufferとは、readメソッドとwriteメソッドを持つ可変サイズのバイトバッファーです。 色々おさらいしていきます。bufferとは基本的には、データを一時的に記憶する場所のことを言います。なのでその一時保存領域を読んだり、一時領域に書いたりすることができるわけです。\n// バッファからlen(p)サイズ文を読み取りpに格納する package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { str := \u0026#34;123456789\u0026#34; b := []byte(str) fmt.Println(b) b2 := []byte{0, 0} buf := bytes.NewBuffer(b) _, err := buf.Read(b2) if err != nil { panic(err) } // バッファからlen(p)サイズ文を読み取りpに格納する \tfmt.Println(string(b2)) } 実行すると12という結果が得られます。b2は2つの領域を定義しており、それが上書きされる挙動になっています。一方Writeの方は、\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { str := \u0026#34;123456789\u0026#34; b := []byte(str) fmt.Println(b) // :;を表すバイト配列 \tb2 := []byte{58, 59} buf := bytes.NewBuffer(b) _, err := buf.Write(b2) if err != nil { panic(err) } fmt.Println(string(b2)) // 一時領域を文字列に変換 \tfmt.Println(buf.String()) } 上記のプログラムの実行結果としては、123456789:;が得られます。b2に定義していた内容が、byte.bufferの内部領域に付け加えられ、文字列変換時に標準出力に出てきます。\nこんな感じでbytes.buffer型は中にデータを可変長として持ち、入力であるバイトのスライスに対して、読み込み結果を入れるReadメソッドとスライスの内容を書き込むWriteメソッドがあり、配列のサイズなど考えずに操作可能になります。 このReadメソッドとWriteメソッドを持つということ、つまり、io.Readerとio.Writerというインターフェースで利用できるというのがGo言語で強みになっていきます。\n","permalink":"https://lottotto.github.io/blog/posts/go-bytebuffer/","summary":"モチベーション Goの受け取ったデータを読んだり書いたりうまくできているのは、ReadメソッドとWriteメソッド、そしてどのメソッドを持つ、io.Reader、io.Writerといったインターフェースである。bytes.bufferをお題に色々忘れないようにメモしていく\nbyteとは 1バイトの範囲（1から255）を表すデータ型。 Go言語では、ファイル処理だったり、画像だったり、リクエストだったり色々な面で[]byteが出てくる。 もちろんstringも文字コードで表現されることから2バイトであるので、bytes型のスライスとして表現されることは多い。 []byteとstringの変換は下記の通り\n// []bytes -\u0026gt; string の変換 str := string([]bytes) // string -\u0026gt; []bytesの変換 b := []byte(str) このようにbyte型のスライスは頻出で簡単にstringに変換できる。このbyte型のスライスを色々簡単に操作できるようなパッケージがbytesパッケージになる。詳しくは公式ドキュメント参照。https://pkg.go.dev/byte\nbytesパッケージの中で2つだけ型が宣言されている.bytes.buffer型とreader型である。これをみていく\nbytes.bufferとは bytes.bufferとは、readメソッドとwriteメソッドを持つ可変サイズのバイトバッファーです。 色々おさらいしていきます。bufferとは基本的には、データを一時的に記憶する場所のことを言います。なのでその一時保存領域を読んだり、一時領域に書いたりすることができるわけです。\n// バッファからlen(p)サイズ文を読み取りpに格納する package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { str := \u0026#34;123456789\u0026#34; b := []byte(str) fmt.Println(b) b2 := []byte{0, 0} buf := bytes.NewBuffer(b) _, err := buf.Read(b2) if err != nil { panic(err) } // バッファからlen(p)サイズ文を読み取りpに格納する \tfmt.Println(string(b2)) } 実行すると12という結果が得られます。b2は2つの領域を定義しており、それが上書きされる挙動になっています。一方Writeの方は、","title":"go言語のbyte.bufferについて"},{"content":"Profile 若手のシステムエンジニア。アプリと基盤チームがこぼれがちな領域で食べています。例えばコンテナ、CICD、Observabilityあたりが得意領域のつもり。最近はクラウドも。\nめも どうせ続かないと思うのですが、調べた内容などを忘れないようにするためにHugo と Github Pageを利用してブログ的な何かを始めてみました。素人が書いた内容なので、間違った部分やアプデにより解消された部分もあります。その時はご指摘いただけると助かります。\n","permalink":"https://lottotto.github.io/blog/about/","summary":"Profile 若手のシステムエンジニア。アプリと基盤チームがこぼれがちな領域で食べています。例えばコンテナ、CICD、Observabilityあたりが得意領域のつもり。最近はクラウドも。\nめも どうせ続かないと思うのですが、調べた内容などを忘れないようにするためにHugo と Github Pageを利用してブログ的な何かを始めてみました。素人が書いた内容なので、間違った部分やアプデにより解消された部分もあります。その時はご指摘いただけると助かります。","title":"aboutme"},{"content":"bazelとは ソースコードをコンパイルして、実行可能形式にしたり、テストをしたりする一連の処理をまとめてやってくれるツールのことをビルドツールと言い、例えばMake,Maven, Gradleなどがある。 もともとgoogle ではBlazeというビルドツールが利用されていて、これをOSS化したのがbazelになる\nbazelの特徴   多言語サポート\n Bazelは多くの言語をサポートしており、任意のプログラミング言語をサポートするように拡張可能。    高レベルのビルド言語\n プロジェクトはBUILDファイルにてで記述。BUILDファイル相互接続された小さなライブラリ、バイナリ、およびテストのセットとしてプロジェクトを記述する簡潔なテキスト形式。対照的に、Makeのようなツールでは、個々のファイルとコンパイラの呼び出しを記述する必要があります。    マルチプラットフォームのサポート\n 同じツールと同じBUILDファイルを使用して、さまざまなアーキテクチャ、さらにはさまざまなプラットフォーム用のソフトウェアを構築可能 GoogleではBazelを使用してデータセンターのシステムで実行されるサーバーアプリケーションから携帯電話で実行されるクライアントアプリまで、あらゆるものを構築。    再現性\n BUILDファイルでは、各ライブラリ、テスト、およびバイナリで直接の依存関係を完全に指定する必要があるため、Bazelはこの依存関係情報を使用して、ソースファイルに変更を加えたときに何を再構築する必要があるか、およびどのタスクを並行して実行できるかを認識。 これはすべてのビルドが常に同じ結果を生成することを意味します。    スケーラブル\n Bazelは大規模なビルドを処理可能。 Googleでは、サーバーバイナリに10万のソースファイルがあるのが一般的であり、ファイルが変更されていないビルドには約200ミリ秒かかかるらしい    Googleはなぜbazelを利用するのか  Makeの場合  人力でMakefileを書くのは結構辛い   Mavenの場合  Javaだけなのが辛い Bazelではコードを再利用可能な単位に細分化することを推奨しており、差分だけをビルドするといったことが可能なので   gradleの場合  Gradleの設定ファイルが読みづらいのが辛い Bazelは各アクションが何を行うかを正確に理解できるのでより並列化され、より再現性が高くなるらしい    gradle 陣営はbazelを使うとBUILDファイルがめちゃくちゃ増えることなどで管理コストが増大することを理由に反論しています 参考: https://blog.gradle.org/gradle-vs-bazel-jvm\n対応言語やフレームワーク https://awesomebazel.com/ ほとんど一般的な言語やフレームワークは対応していそうですね。\n実際にどのような会社やOSSがbazelを使用しているのか https://bazel.build/users.html に書いてあるが気になった部分を書きます。\n 日本企業が少ない。  2022/01/15現在、LINEだけしかない。まだまだ日本でbazelが受けいられていない状態かなと思っています   KubernetesはBazelビルドから脱却したみたい  どうやらKubernetesではビルドが煩雑で大変だったのをmakeに統一したようです。 https://github.com/kubernetes/enhancements/issues/2420 https://github.com/kubernetes/kubernetes/issues/88553 基本ほとんどがGoで書かれているので、まあbazelのおいしさを完全に享受できるとは思わないです。    インストール方法 自分はMacを使用したのでMacでの説明になります 参考: https://docs.bazel.build/versions/4.2.2/install-os-x.html\nexport BAZEL_VERSION=3.2.0 curl -fLO \u0026#34;https://github.com/bazelbuild/bazel/releases/download/${BAZEL_VERSION}/bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh\u0026#34; # 実行権限をつけて実行 chmod +x \u0026#34;bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh\u0026#34; ./bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh --user user@usernoMacBook-Pro tmp % ./bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh --user Bazel installer --------------- Bazel is bundled with software licensed under the GPLv2 with Classpath exception. You can find the sources next to the installer on our release page: https://github.com/bazelbuild/bazel/releases # setting authenticate proxy # Binary package at HEAD (@15371720ae0c4) - [Commit](https://github.com/bazelbuild/bazel/commit/15371720ae0c4) Uncompressing......Extracting Bazel installation... . Bazel is now installed! Make sure you have \u0026quot;/Users/user/bin\u0026quot; in your path. For bash completion, add the following line to your : source /Users/user/.bazel/bin/bazel-complete.bash For fish shell completion, link this file into your /Users/user/.config/fish/completions/ directory: ln -s /Users/user/.bazel/bin/bazel.fish /Users/user/.config/fish/completions/bazel.fish See http://bazel.build/docs/getting-started.html to start a new project! bazelの始め方  WORKSPACEファイルの用意  bazelにおけるワークスペースとは、ビルドするソフトウェアのソースファイルとビルド出力先を含むディレクトリ.各ワークスペースごとにはWORKSPACEというテキストファイルがあり、空も場合もあれば、外部依存関係への参照が含まれている. つまりプロジェクトのルートにはWORKSPACEがあればOK   BUILDファイルの用意  Starlarkという言語を利用して、ビルドターゲットを指定することでBUILDファイルを記述.  java_binary( name = \u0026quot;ProjectRunner\u0026quot;, srcs = [\u0026quot;src/main/java/com/example/ProjectRunner.java\u0026quot;], main_class = \u0026quot;com.example.ProjectRunner\u0026quot;, deps = [\u0026quot;:greeter\u0026quot;], ) java_library( name = \u0026quot;greeter\u0026quot;, srcs = [\u0026quot;src/main/java/com/example/Greeting.java\u0026quot;], )  Bazelがビルドするソースコードとその依存関係、そしてbazelが利用するビルドルールなどが記載される   ビルドする  bazel build //path/to/package:\u0026lt;ビルドターゲット名\u0026gt;でビルド可能  user@usernoMacBook-Pro java-tutorial % bazel build //:ProjectRunner INFO: Analyzed target //:ProjectRunner (0 packages loaded, 0 targets configured). INFO: Found 1 target... Target //:ProjectRunner up-to-date: bazel-bin/ProjectRunner.jar bazel-bin/ProjectRunner INFO: Elapsed time: 0.431s, Critical Path: 0.01s INFO: 1 process: 1 internal. INFO: Build completed successfully, 1 total action   サンプルプロジェクトの解説 対象プロジェクトは https://github.com/bazelbuild/examples/tree/main/java-tutorial\nワークスペースの立ち上げ WORKSPACEファイルには外部依存関係が記載されます。本プロジェクトでは特に外部参照の依存関係についてないので、空欄のままです。\nBUILD ファイルの理解 例えば下記のビルドファイルでは、java_binaryというルールがProjectRunnerという名前で作成されています。\njava_binary( name = \u0026#34;ProjectRunner\u0026#34;, srcs = glob([\u0026#34;src/main/java/com/example/*.java\u0026#34;]), ) 公式ドキュメントのJavaRulesを参照すると、\n Builds a Java archive (\u0026ldquo;jar file\u0026rdquo;), plus a wrapper shell script with the same name as the rule. The wrapper shell script uses a classpath that includes, among other things, a jar file for each library on which the binary depends.\n つまり、java_binaryコマンドは、jarと同名のラッパースクリプトを作成するルールのようです。\nプロジェクトのビルド 上記のBUILDファイルの元でビルドするコマンドは下記になります。/はWORKSPACEと同じ階層にあるBUILDファイルを示しています。\n$ bazel build //:ProjectRunner 依存関係のグラフを出力 このコマンドを実行すること\n$ bazel query --notool_deps --noimplicit_deps \u0026quot;deps(//:ProjectRunner)\u0026quot; --output graph digraph mygraph { node [shape=box]; \u0026quot;//:ProjectRunner\u0026quot; \u0026quot;//:ProjectRunner\u0026quot; -\u0026gt; \u0026quot;//:src/main/java/com/example/Greeting.java\\n//:src/main/java/com/example/ProjectRunner.java\u0026quot; \u0026quot;//:src/main/java/com/example/Greeting.java\\n//:src/main/java/com/example/ProjectRunner.java\u0026quot; } こんな感じの依存関係を出すことができます。今回のプロジェクトでは簡単なので役に立たないですが、複雑になってくると便利かと思います。\nもちろんgradleにも同じ機能はあります。\nbazelビルドを改良する ここからbazelビルドを改良して、モジュールを切り出します。\nload(\u0026#34;@rules_java//java:defs.bzl\u0026#34;, \u0026#34;java_binary\u0026#34;) java_binary( name = \u0026#34;ProjectRunner\u0026#34;, srcs = [\u0026#34;src/main/java/com/example/ProjectRunner.java\u0026#34;], main_class = \u0026#34;com.example.ProjectRunner\u0026#34;, deps = [\u0026#34;:greeter\u0026#34;], ) java_library( name = \u0026#34;greeter\u0026#34;, srcs = [\u0026#34;src/main/java/com/example/Greeting.java\u0026#34;], ) java_binaryのところで2つ出てきました。こちらも公式ドキュメントに書いてあるのですが、main_classはエントリーポイントとなるmain()関数を持っているクラスを指定しています。deps部分は依存しているルールターゲット名になります。\nbazel build //:ProjectRunner これによって、java_binary(ProjectRunner)とjava_library(greeter)が実行され、それぞれProjectRunner.jarとlibgreeter.jarが作成されました。 依存関係の図も出してみると想像した通り、greeterへの依存関係が追加されています。\n$ bazel query --notool_deps --noimplicit_deps \u0026#34;deps(//:ProjectRunner)\u0026#34; --output graph digraph mygraph { node [shape=box]; \u0026#34;//:ProjectRunner\u0026#34; \u0026#34;//:ProjectRunner\u0026#34; -\u0026gt; \u0026#34;//:greeter\u0026#34; \u0026#34;//:ProjectRunner\u0026#34; -\u0026gt; \u0026#34;//:src/main/java/com/example/ProjectRunner.java\u0026#34; \u0026#34;//:src/main/java/com/example/ProjectRunner.java\u0026#34; \u0026#34;//:greeter\u0026#34; \u0026#34;//:greeter\u0026#34; -\u0026gt; \u0026#34;//:src/main/java/com/example/Greeting.java\u0026#34; \u0026#34;//:src/main/java/com/example/Greeting.java\u0026#34; } Javaの推移的依存関係について ビルドツールの鬼門といえば推移的依存関係です。推移的依存関係とは、ライブラリAがライブラリBに依存していて、ライブラリBがライブラリCに依存していることを言います。bazelにおける推移的依存関係を解決するにはrules_jvm_externalを使えばOKだそうです。使い方はWORKSPACEに記載すればOKです\n参考: https://blog.bazel.build/2019/03/31/rules-jvm-external-maven.html\nload(\u0026#34;@bazel_tools//tools/build_defs/repo:http.bzl\u0026#34;, \u0026#34;http_archive\u0026#34;) http_archive( name = \u0026#34;rules_jvm_external\u0026#34;, strip_prefix = \u0026#34;rules_jvm_external-1.2\u0026#34;, sha256 = \u0026#34;e5c68b87f750309a79f59c2b69ead5c3221ffa54ff9496306937bfa1c9c8c86b\u0026#34;, url = \u0026#34;https://github.com/bazelbuild/rules_jvm_external/archive/1.2.zip\u0026#34; ) その後BUILDファイルに、上記のrules_jvm_externalをloadした上でmaven_installルールを記載します。\nload(\u0026#34;@rules_jvm_external//:defs.bzl\u0026#34;, \u0026#34;maven_install\u0026#34;) maven_install( name = \u0026#34;maven\u0026#34;, artifacts = [ \u0026#34;androidx.test.espresso:espresso-core:3.1.1\u0026#34;, \u0026#34;com.google.guava:guava:27.0-android\u0026#34;, ], repositories = [ \u0026#34;https://maven.google.com\u0026#34;, \u0026#34;https://repo1.maven.org/maven2\u0026#34;, ], fetch_sources = True, # Fetch source jars. Defaults to False. ) またこのmaven_installでは、推移的依存関係が衝突したときユーザーで指定できるようになっています。version_conflict_policy=\u0026quot;pinned\u0026quot;と記載することで、明記されたものを使うことができるようです。ただめちゃくちゃ書くのが辛そうですね。 https://github.com/bazelbuild/rules_jvm_external#resolving-user-specified-and-transitive-dependency-version-conflicts\nGo言語でBazelを利用する場合 今度まとめてみたいとおもいます。下記参考先を読む限り、gazelleといったものを使うことでBUILDファイルを自動生成できるのが良いということでした。\n参考: https://note.crohaco.net/2020/bazel-golang/\n考察 ここからbazelがじゃあ使えるかどうかというのを考えていきます。気になったポイントとしては2点です。\nBazelが役に立つのは、モノリポかつシステムのポリグロット化進んだ時になるのではないか。 bazelが強いところは、多言語多フレームワーク対応しているところと考えています。多言語多フレームワークをビルドするには環境構築がかなり大変なので、bazel一つ用意すればビルドできるようになるというのはとても便利だと思います。また書くパッケージごとにBUILDファイルがあるため、差分ビルドが容易にできると思います。パイプラインのこのファイルが変更されたらこのコマンドを実行するといった制御を実施することで、ビルドが高速化されそうですね。そして、この細かく制御したい、他のビルドも同時にしたいというのは、ポリグロット(多言語)かつモノリポジドリで運用しているが前提になるのかなと・・・。これができている組織ってかなり少ないと思います。\nDockerまわりなどは標準のやり方の方が理解しやすく、また参考文献も少なく学習コストが高い。 Dockerビルドのものを見てみましたが、DockerFileを使ったビルドの方がどうしてもやりやすそうです。このような文献も少なく、どうしても学習コストが高いものになってしまうのでしょうか。学習コストが高くなった結果、ビルドおじさんといったそういう専門家が必要になるのではないでしょうか。実際Kubernetesでは、go標準のビルドが短時間になった結果、makeとbazelを両立して管理する必要なくないかということになり、Makeに統一されました。もちろん理由の一つとしてGoのエコシステムではbazelが一般的ではなく、利用する人やコントリビュータを取り込むのに弊害になりそうということもあります\nまとめ  bazelは多言語対応だったりビルドを細かくする仕組みがあり、機能としては高い。 しかし、前提としてモノリポやポリグロット化されていることが前提であり、それを一般的に利用できている組織はまだないのではないか。 今後googleようなリポジトリ構成が一般的になる可能性はあるので、しばらくはgradleや言語の標準ビルドツールで良いかと思うが、ウオッチして損はないのではないか。  ","permalink":"https://lottotto.github.io/blog/posts/bazel/","summary":"bazelとは ソースコードをコンパイルして、実行可能形式にしたり、テストをしたりする一連の処理をまとめてやってくれるツールのことをビルドツールと言い、例えばMake,Maven, Gradleなどがある。 もともとgoogle ではBlazeというビルドツールが利用されていて、これをOSS化したのがbazelになる\nbazelの特徴   多言語サポート\n Bazelは多くの言語をサポートしており、任意のプログラミング言語をサポートするように拡張可能。    高レベルのビルド言語\n プロジェクトはBUILDファイルにてで記述。BUILDファイル相互接続された小さなライブラリ、バイナリ、およびテストのセットとしてプロジェクトを記述する簡潔なテキスト形式。対照的に、Makeのようなツールでは、個々のファイルとコンパイラの呼び出しを記述する必要があります。    マルチプラットフォームのサポート\n 同じツールと同じBUILDファイルを使用して、さまざまなアーキテクチャ、さらにはさまざまなプラットフォーム用のソフトウェアを構築可能 GoogleではBazelを使用してデータセンターのシステムで実行されるサーバーアプリケーションから携帯電話で実行されるクライアントアプリまで、あらゆるものを構築。    再現性\n BUILDファイルでは、各ライブラリ、テスト、およびバイナリで直接の依存関係を完全に指定する必要があるため、Bazelはこの依存関係情報を使用して、ソースファイルに変更を加えたときに何を再構築する必要があるか、およびどのタスクを並行して実行できるかを認識。 これはすべてのビルドが常に同じ結果を生成することを意味します。    スケーラブル\n Bazelは大規模なビルドを処理可能。 Googleでは、サーバーバイナリに10万のソースファイルがあるのが一般的であり、ファイルが変更されていないビルドには約200ミリ秒かかかるらしい    Googleはなぜbazelを利用するのか  Makeの場合  人力でMakefileを書くのは結構辛い   Mavenの場合  Javaだけなのが辛い Bazelではコードを再利用可能な単位に細分化することを推奨しており、差分だけをビルドするといったことが可能なので   gradleの場合  Gradleの設定ファイルが読みづらいのが辛い Bazelは各アクションが何を行うかを正確に理解できるのでより並列化され、より再現性が高くなるらしい    gradle 陣営はbazelを使うとBUILDファイルがめちゃくちゃ増えることなどで管理コストが増大することを理由に反論しています 参考: https://blog.gradle.org/gradle-vs-bazel-jvm\n対応言語やフレームワーク https://awesomebazel.com/ ほとんど一般的な言語やフレームワークは対応していそうですね。\n実際にどのような会社やOSSがbazelを使用しているのか https://bazel.build/users.html に書いてあるが気になった部分を書きます。","title":"bazel触ってみた"}]