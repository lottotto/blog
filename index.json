[{"content":"モチベーション Goの受け取ったデータを読んだり書いたりうまくできているのは、ReadメソッドとWriteメソッド、そしてどのメソッドを持つ、io.Reader、io.Writerといったインターフェースである。bytes.bufferをお題に色々忘れないようにメモしていく\nbyteとは 1バイトの範囲（1から255）を表すデータ型。 Go言語では、ファイル処理だったり、画像だったり、リクエストだったり色々な面で[]byteが出てくる。 もちろんstringも文字コードで表現されることから2バイトであるので、bytes型のスライスとして表現されることは多い。 []byteとstringの変換は下記の通り\n// []bytes -\u0026gt; string の変換 str := string([]bytes) // string -\u0026gt; []bytesの変換 b := []byte(str) このようにbyte型のスライスは頻出で簡単にstringに変換できる。このbyte型のスライスを色々簡単に操作できるようなパッケージがbytesパッケージになる。詳しくは公式ドキュメント参照。https://pkg.go.dev/byte\nbytesパッケージの中で2つだけ型が宣言されている.bytes.buffer型とreader型である。これをみていく\nbytes.bufferとは bytes.bufferとは、readメソッドとwriteメソッドを持つ可変サイズのバイトバッファーです。 色々おさらいしていきます。bufferとは基本的には、データを一時的に記憶する場所のことを言います。なのでその一時保存領域を読んだり、一時領域に書いたりすることができるわけです。\n// バッファからlen(p)サイズ文を読み取りpに格納する package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { str := \u0026#34;123456789\u0026#34; b := []byte(str) fmt.Println(b) b2 := []byte{0, 0} buf := bytes.NewBuffer(b) _, err := buf.Read(b2) if err != nil { panic(err) } // バッファからlen(p)サイズ文を読み取りpに格納する \tfmt.Println(string(b2)) } 実行すると12という結果が得られます。b2は2つの領域を定義しており、それが上書きされる挙動になっています。一方Writeの方は、\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { str := \u0026#34;123456789\u0026#34; b := []byte(str) fmt.Println(b) // :;を表すバイト配列 \tb2 := []byte{58, 59} buf := bytes.NewBuffer(b) _, err := buf.Write(b2) if err != nil { panic(err) } fmt.Println(string(b2)) // 一時領域を文字列に変換 \tfmt.Println(buf.String()) } 上記のプログラムの実行結果としては、123456789:;が得られます。b2に定義していた内容が、byte.bufferの内部領域に付け加えられ、文字列変換時に標準出力に出てきます。\nこんな感じでbytes.buffer型は中にデータを可変長として持ち、入力であるバイトのスライスに対して、読み込み結果を入れるReadメソッドとスライスの内容を書き込むWriteメソッドがあり、配列のサイズなど考えずに操作可能になります。 このReadメソッドとWriteメソッドを持つということ、つまり、io.Readerとio.Writerというインターフェースで利用できるというのがGo言語で強みになっていきます。\n","permalink":"https://lottotto.github.io/blog/posts/go-ioreader/","summary":"モチベーション Goの受け取ったデータを読んだり書いたりうまくできているのは、ReadメソッドとWriteメソッド、そしてどのメソッドを持つ、io.Reader、io.Writerといったインターフェースである。bytes.bufferをお題に色々忘れないようにメモしていく\nbyteとは 1バイトの範囲（1から255）を表すデータ型。 Go言語では、ファイル処理だったり、画像だったり、リクエストだったり色々な面で[]byteが出てくる。 もちろんstringも文字コードで表現されることから2バイトであるので、bytes型のスライスとして表現されることは多い。 []byteとstringの変換は下記の通り\n// []bytes -\u0026gt; string の変換 str := string([]bytes) // string -\u0026gt; []bytesの変換 b := []byte(str) このようにbyte型のスライスは頻出で簡単にstringに変換できる。このbyte型のスライスを色々簡単に操作できるようなパッケージがbytesパッケージになる。詳しくは公式ドキュメント参照。https://pkg.go.dev/byte\nbytesパッケージの中で2つだけ型が宣言されている.bytes.buffer型とreader型である。これをみていく\nbytes.bufferとは bytes.bufferとは、readメソッドとwriteメソッドを持つ可変サイズのバイトバッファーです。 色々おさらいしていきます。bufferとは基本的には、データを一時的に記憶する場所のことを言います。なのでその一時保存領域を読んだり、一時領域に書いたりすることができるわけです。\n// バッファからlen(p)サイズ文を読み取りpに格納する package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { str := \u0026#34;123456789\u0026#34; b := []byte(str) fmt.Println(b) b2 := []byte{0, 0} buf := bytes.NewBuffer(b) _, err := buf.Read(b2) if err != nil { panic(err) } // バッファからlen(p)サイズ文を読み取りpに格納する \tfmt.Println(string(b2)) } 実行すると12という結果が得られます。b2は2つの領域を定義しており、それが上書きされる挙動になっています。一方Writeの方は、","title":"go言語のbyte.bufferについて"},{"content":"bazelとは ソースコードをコンパイルして、実行可能形式にしたり、テストをしたりする一連の処理をまとめてやってくれるツールのことをビルドツールと言い、例えばMake,Maven, Gradleなどがある。 もともとgoogle ではBlazeというビルドツールが利用されていて、これをOSS化したのがbazelになる\nbazelの特徴   多言語サポート\n Bazelは多くの言語をサポートしており、任意のプログラミング言語をサポートするように拡張可能。    高レベルのビルド言語\n プロジェクトはBUILDファイルにてで記述。BUILDファイル相互接続された小さなライブラリ、バイナリ、およびテストのセットとしてプロジェクトを記述する簡潔なテキスト形式。対照的に、Makeのようなツールでは、個々のファイルとコンパイラの呼び出しを記述する必要があります。    マルチプラットフォームのサポート\n 同じツールと同じBUILDファイルを使用して、さまざまなアーキテクチャ、さらにはさまざまなプラットフォーム用のソフトウェアを構築可能 GoogleではBazelを使用してデータセンターのシステムで実行されるサーバーアプリケーションから携帯電話で実行されるクライアントアプリまで、あらゆるものを構築。    再現性\n BUILDファイルでは、各ライブラリ、テスト、およびバイナリで直接の依存関係を完全に指定する必要があるため、Bazelはこの依存関係情報を使用して、ソースファイルに変更を加えたときに何を再構築する必要があるか、およびどのタスクを並行して実行できるかを認識。 これはすべてのビルドが常に同じ結果を生成することを意味します。    スケーラブル\n Bazelは大規模なビルドを処理可能。 Googleでは、サーバーバイナリに10万のソースファイルがあるのが一般的であり、ファイルが変更されていないビルドには約200ミリ秒かかかるらしい    Googleはなぜbazelを利用するのか  Makeの場合  人力でMakefileを書くのは結構辛い   Mavenの場合  Javaだけなのが辛い Bazelではコードを再利用可能な単位に細分化することを推奨しており、差分だけをビルドするといったことが可能なので   gradleの場合  Gradleの設定ファイルが読みづらいのが辛い Bazelは各アクションが何を行うかを正確に理解できるのでより並列化され、より再現性が高くなるらしい    gradle 陣営はbazelを使うとBUILDファイルがめちゃくちゃ増えることなどで管理コストが増大することを理由に反論しています 参考: https://blog.gradle.org/gradle-vs-bazel-jvm\n対応言語やフレームワーク https://awesomebazel.com/ ほとんど一般的な言語やフレームワークは対応していそうですね。\n実際にどのような会社やOSSがbazelを使用しているのか https://bazel.build/users.html に書いてあるが気になった部分を書きます。\n 日本企業が少ない。  2022/01/15現在、LINEだけしかない。まだまだ日本でbazelが受けいられていない状態かなと思っています   KubernetesはBazelビルドから脱却したみたい  どうやらKubernetesではビルドが煩雑で大変だったのをmakeに統一したようです。 https://github.com/kubernetes/enhancements/issues/2420 https://github.com/kubernetes/kubernetes/issues/88553 基本ほとんどがGoで書かれているので、まあbazelのおいしさを完全に享受できるとは思わないです。    インストール方法 自分はMacを使用したのでMacでの説明になります 参考: https://docs.bazel.build/versions/4.2.2/install-os-x.html\nexport BAZEL_VERSION=3.2.0 curl -fLO \u0026#34;https://github.com/bazelbuild/bazel/releases/download/${BAZEL_VERSION}/bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh\u0026#34; # 実行権限をつけて実行 chmod +x \u0026#34;bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh\u0026#34; ./bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh --user user@usernoMacBook-Pro tmp % ./bazel-${BAZEL_VERSION}-installer-darwin-x86_64.sh --user Bazel installer --------------- Bazel is bundled with software licensed under the GPLv2 with Classpath exception. You can find the sources next to the installer on our release page: https://github.com/bazelbuild/bazel/releases # setting authenticate proxy # Binary package at HEAD (@15371720ae0c4) - [Commit](https://github.com/bazelbuild/bazel/commit/15371720ae0c4) Uncompressing......Extracting Bazel installation... . Bazel is now installed! Make sure you have \u0026quot;/Users/user/bin\u0026quot; in your path. For bash completion, add the following line to your : source /Users/user/.bazel/bin/bazel-complete.bash For fish shell completion, link this file into your /Users/user/.config/fish/completions/ directory: ln -s /Users/user/.bazel/bin/bazel.fish /Users/user/.config/fish/completions/bazel.fish See http://bazel.build/docs/getting-started.html to start a new project! bazelの始め方  WORKSPACEファイルの用意  bazelにおけるワークスペースとは、ビルドするソフトウェアのソースファイルとビルド出力先を含むディレクトリ.各ワークスペースごとにはWORKSPACEというテキストファイルがあり、空も場合もあれば、外部依存関係への参照が含まれている. つまりプロジェクトのルートにはWORKSPACEがあればOK   BUILDファイルの用意  Starlarkという言語を利用して、ビルドターゲットを指定することでBUILDファイルを記述.  java_binary( name = \u0026quot;ProjectRunner\u0026quot;, srcs = [\u0026quot;src/main/java/com/example/ProjectRunner.java\u0026quot;], main_class = \u0026quot;com.example.ProjectRunner\u0026quot;, deps = [\u0026quot;:greeter\u0026quot;], ) java_library( name = \u0026quot;greeter\u0026quot;, srcs = [\u0026quot;src/main/java/com/example/Greeting.java\u0026quot;], )  Bazelがビルドするソースコードとその依存関係、そしてbazelが利用するビルドルールなどが記載される   ビルドする  bazel build //path/to/package:\u0026lt;ビルドターゲット名\u0026gt;でビルド可能  user@usernoMacBook-Pro java-tutorial % bazel build //:ProjectRunner INFO: Analyzed target //:ProjectRunner (0 packages loaded, 0 targets configured). INFO: Found 1 target... Target //:ProjectRunner up-to-date: bazel-bin/ProjectRunner.jar bazel-bin/ProjectRunner INFO: Elapsed time: 0.431s, Critical Path: 0.01s INFO: 1 process: 1 internal. INFO: Build completed successfully, 1 total action   サンプルプロジェクトの解説 対象プロジェクトは https://github.com/bazelbuild/examples/tree/main/java-tutorial\nワークスペースの立ち上げ WORKSPACEファイルには外部依存関係が記載されます。本プロジェクトでは特に外部参照の依存関係についてないので、空欄のままです。\nBUILD ファイルの理解 例えば下記のビルドファイルでは、java_binaryというルールがProjectRunnerという名前で作成されています。\njava_binary( name = \u0026#34;ProjectRunner\u0026#34;, srcs = glob([\u0026#34;src/main/java/com/example/*.java\u0026#34;]), ) 公式ドキュメントのJavaRulesを参照すると、\n Builds a Java archive (\u0026ldquo;jar file\u0026rdquo;), plus a wrapper shell script with the same name as the rule. The wrapper shell script uses a classpath that includes, among other things, a jar file for each library on which the binary depends.\n つまり、java_binaryコマンドは、jarと同名のラッパースクリプトを作成するルールのようです。\nプロジェクトのビルド 上記のBUILDファイルの元でビルドするコマンドは下記になります。/はWORKSPACEと同じ階層にあるBUILDファイルを示しています。\n$ bazel build //:ProjectRunner 依存関係のグラフを出力 このコマンドを実行すること\n$ bazel query --notool_deps --noimplicit_deps \u0026quot;deps(//:ProjectRunner)\u0026quot; --output graph digraph mygraph { node [shape=box]; \u0026quot;//:ProjectRunner\u0026quot; \u0026quot;//:ProjectRunner\u0026quot; -\u0026gt; \u0026quot;//:src/main/java/com/example/Greeting.java\\n//:src/main/java/com/example/ProjectRunner.java\u0026quot; \u0026quot;//:src/main/java/com/example/Greeting.java\\n//:src/main/java/com/example/ProjectRunner.java\u0026quot; } こんな感じの依存関係を出すことができます。今回のプロジェクトでは簡単なので役に立たないですが、複雑になってくると便利かと思います。\nもちろんgradleにも同じ機能はあります。\nbazelビルドを改良する ここからbazelビルドを改良して、モジュールを切り出します。\nload(\u0026#34;@rules_java//java:defs.bzl\u0026#34;, \u0026#34;java_binary\u0026#34;) java_binary( name = \u0026#34;ProjectRunner\u0026#34;, srcs = [\u0026#34;src/main/java/com/example/ProjectRunner.java\u0026#34;], main_class = \u0026#34;com.example.ProjectRunner\u0026#34;, deps = [\u0026#34;:greeter\u0026#34;], ) java_library( name = \u0026#34;greeter\u0026#34;, srcs = [\u0026#34;src/main/java/com/example/Greeting.java\u0026#34;], ) java_binaryのところで2つ出てきました。こちらも公式ドキュメントに書いてあるのですが、main_classはエントリーポイントとなるmain()関数を持っているクラスを指定しています。deps部分は依存しているルールターゲット名になります。\nbazel build //:ProjectRunner これによって、java_binary(ProjectRunner)とjava_library(greeter)が実行され、それぞれProjectRunner.jarとlibgreeter.jarが作成されました。 依存関係の図も出してみると想像した通り、greeterへの依存関係が追加されています。\n$ bazel query --notool_deps --noimplicit_deps \u0026#34;deps(//:ProjectRunner)\u0026#34; --output graph digraph mygraph { node [shape=box]; \u0026#34;//:ProjectRunner\u0026#34; \u0026#34;//:ProjectRunner\u0026#34; -\u0026gt; \u0026#34;//:greeter\u0026#34; \u0026#34;//:ProjectRunner\u0026#34; -\u0026gt; \u0026#34;//:src/main/java/com/example/ProjectRunner.java\u0026#34; \u0026#34;//:src/main/java/com/example/ProjectRunner.java\u0026#34; \u0026#34;//:greeter\u0026#34; \u0026#34;//:greeter\u0026#34; -\u0026gt; \u0026#34;//:src/main/java/com/example/Greeting.java\u0026#34; \u0026#34;//:src/main/java/com/example/Greeting.java\u0026#34; } Javaの推移的依存関係について ビルドツールの鬼門といえば推移的依存関係です。推移的依存関係とは、ライブラリAがライブラリBに依存していて、ライブラリBがライブラリCに依存していることを言います。bazelにおける推移的依存関係を解決するにはrules_jvm_externalを使えばOKだそうです。使い方はWORKSPACEに記載すればOKです\n参考: https://blog.bazel.build/2019/03/31/rules-jvm-external-maven.html\nload(\u0026#34;@bazel_tools//tools/build_defs/repo:http.bzl\u0026#34;, \u0026#34;http_archive\u0026#34;) http_archive( name = \u0026#34;rules_jvm_external\u0026#34;, strip_prefix = \u0026#34;rules_jvm_external-1.2\u0026#34;, sha256 = \u0026#34;e5c68b87f750309a79f59c2b69ead5c3221ffa54ff9496306937bfa1c9c8c86b\u0026#34;, url = \u0026#34;https://github.com/bazelbuild/rules_jvm_external/archive/1.2.zip\u0026#34; ) その後BUILDファイルに、上記のrules_jvm_externalをloadした上でmaven_installルールを記載します。\nload(\u0026#34;@rules_jvm_external//:defs.bzl\u0026#34;, \u0026#34;maven_install\u0026#34;) maven_install( name = \u0026#34;maven\u0026#34;, artifacts = [ \u0026#34;androidx.test.espresso:espresso-core:3.1.1\u0026#34;, \u0026#34;com.google.guava:guava:27.0-android\u0026#34;, ], repositories = [ \u0026#34;https://maven.google.com\u0026#34;, \u0026#34;https://repo1.maven.org/maven2\u0026#34;, ], fetch_sources = True, # Fetch source jars. Defaults to False. ) またこのmaven_installでは、推移的依存関係が衝突したときユーザーで指定できるようになっています。version_conflict_policy=\u0026quot;pinned\u0026quot;と記載することで、明記されたものを使うことができるようです。ただめちゃくちゃ書くのが辛そうですね。 https://github.com/bazelbuild/rules_jvm_external#resolving-user-specified-and-transitive-dependency-version-conflicts\nGo言語でBazelを利用する場合 今度まとめてみたいとおもいます。下記参考先を読む限り、gazelleといったものを使うことでBUILDファイルを自動生成できるのが良いということでした。\n参考: https://note.crohaco.net/2020/bazel-golang/\n考察 ここからbazelがじゃあ使えるかどうかというのを考えていきます。気になったポイントとしては2点です。\nBazelが役に立つのは、モノリポかつシステムのポリグロット化進んだ時になるのではないか。 bazelが強いところは、多言語多フレームワーク対応しているところと考えています。多言語多フレームワークをビルドするには環境構築がかなり大変なので、bazel一つ用意すればビルドできるようになるというのはとても便利だと思います。また書くパッケージごとにBUILDファイルがあるため、差分ビルドが容易にできると思います。パイプラインのこのファイルが変更されたらこのコマンドを実行するといった制御を実施することで、ビルドが高速化されそうですね。そして、この細かく制御したい、他のビルドも同時にしたいというのは、ポリグロット(多言語)かつモノリポジドリで運用しているが前提になるのかなと・・・。これができている組織ってかなり少ないと思います。\nDockerまわりなどは標準のやり方の方が理解しやすく、また参考文献も少なく学習コストが高い。 Dockerビルドのものを見てみましたが、DockerFileを使ったビルドの方がどうしてもやりやすそうです。このような文献も少なく、どうしても学習コストが高いものになってしまうのでしょうか。学習コストが高くなった結果、ビルドおじさんといったそういう専門家が必要になるのではないでしょうか。実際Kubernetesでは、go標準のビルドが短時間になった結果、makeとbazelを両立して管理する必要なくないかということになり、Makeに統一されました。もちろん理由の一つとしてGoのエコシステムではbazelが一般的ではなく、利用する人やコントリビュータを取り込むのに弊害になりそうということもあります\nまとめ  bazelは多言語対応だったりビルドを細かくする仕組みがあり、機能としては高い。 しかし、前提としてモノリポやポリグロット化されていることが前提であり、それを一般的に利用できている組織はまだないのではないか。 今後googleようなリポジトリ構成が一般的になる可能性はあるので、しばらくはgradleや言語の標準ビルドツールで良いかと思うが、ウオッチして損はないのではないか。  ","permalink":"https://lottotto.github.io/blog/posts/bazel/","summary":"bazelとは ソースコードをコンパイルして、実行可能形式にしたり、テストをしたりする一連の処理をまとめてやってくれるツールのことをビルドツールと言い、例えばMake,Maven, Gradleなどがある。 もともとgoogle ではBlazeというビルドツールが利用されていて、これをOSS化したのがbazelになる\nbazelの特徴   多言語サポート\n Bazelは多くの言語をサポートしており、任意のプログラミング言語をサポートするように拡張可能。    高レベルのビルド言語\n プロジェクトはBUILDファイルにてで記述。BUILDファイル相互接続された小さなライブラリ、バイナリ、およびテストのセットとしてプロジェクトを記述する簡潔なテキスト形式。対照的に、Makeのようなツールでは、個々のファイルとコンパイラの呼び出しを記述する必要があります。    マルチプラットフォームのサポート\n 同じツールと同じBUILDファイルを使用して、さまざまなアーキテクチャ、さらにはさまざまなプラットフォーム用のソフトウェアを構築可能 GoogleではBazelを使用してデータセンターのシステムで実行されるサーバーアプリケーションから携帯電話で実行されるクライアントアプリまで、あらゆるものを構築。    再現性\n BUILDファイルでは、各ライブラリ、テスト、およびバイナリで直接の依存関係を完全に指定する必要があるため、Bazelはこの依存関係情報を使用して、ソースファイルに変更を加えたときに何を再構築する必要があるか、およびどのタスクを並行して実行できるかを認識。 これはすべてのビルドが常に同じ結果を生成することを意味します。    スケーラブル\n Bazelは大規模なビルドを処理可能。 Googleでは、サーバーバイナリに10万のソースファイルがあるのが一般的であり、ファイルが変更されていないビルドには約200ミリ秒かかかるらしい    Googleはなぜbazelを利用するのか  Makeの場合  人力でMakefileを書くのは結構辛い   Mavenの場合  Javaだけなのが辛い Bazelではコードを再利用可能な単位に細分化することを推奨しており、差分だけをビルドするといったことが可能なので   gradleの場合  Gradleの設定ファイルが読みづらいのが辛い Bazelは各アクションが何を行うかを正確に理解できるのでより並列化され、より再現性が高くなるらしい    gradle 陣営はbazelを使うとBUILDファイルがめちゃくちゃ増えることなどで管理コストが増大することを理由に反論しています 参考: https://blog.gradle.org/gradle-vs-bazel-jvm\n対応言語やフレームワーク https://awesomebazel.com/ ほとんど一般的な言語やフレームワークは対応していそうですね。\n実際にどのような会社やOSSがbazelを使用しているのか https://bazel.build/users.html に書いてあるが気になった部分を書きます。","title":"bazel触ってみた"}]