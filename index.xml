<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>lottoHub</title><link>https://lottotto.github.io/blog/</link><description>Recent content on lottoHub</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 29 Jan 2022 17:20:36 +0900</lastBuildDate><atom:link href="https://lottotto.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>go言語のbyte.bufferについて</title><link>https://lottotto.github.io/blog/posts/go-ioreader/</link><pubDate>Sat, 29 Jan 2022 17:20:36 +0900</pubDate><guid>https://lottotto.github.io/blog/posts/go-ioreader/</guid><description>モチベーション Goの受け取ったデータを読んだり書いたりうまくできているのは、ReadメソッドとWriteメソッド、そしてどのメソッドを持つ、io.Reader、io.Writerといったインターフェースである。bytes.bufferをお題に色々忘れないようにメモしていく
byteとは 1バイトの範囲（1から255）を表すデータ型。 Go言語では、ファイル処理だったり、画像だったり、リクエストだったり色々な面で[]byteが出てくる。 もちろんstringも文字コードで表現されることから2バイトであるので、bytes型のスライスとして表現されることは多い。 []byteとstringの変換は下記の通り
// []bytes -&amp;gt; string の変換 str := string([]bytes) // string -&amp;gt; []bytesの変換 b := []byte(str) このようにbyte型のスライスは頻出で簡単にstringに変換できる。このbyte型のスライスを色々簡単に操作できるようなパッケージがbytesパッケージになる。詳しくは公式ドキュメント参照。https://pkg.go.dev/byte
bytesパッケージの中で2つだけ型が宣言されている.bytes.buffer型とreader型である。これをみていく
bytes.bufferとは bytes.bufferとは、readメソッドとwriteメソッドを持つ可変サイズのバイトバッファーです。 色々おさらいしていきます。bufferとは基本的には、データを一時的に記憶する場所のことを言います。なのでその一時保存領域を読んだり、一時領域に書いたりすることができるわけです。
// バッファからlen(p)サイズ文を読み取りpに格納する package main import ( &amp;#34;bytes&amp;#34; &amp;#34;fmt&amp;#34; ) func main() { str := &amp;#34;123456789&amp;#34; b := []byte(str) fmt.Println(b) b2 := []byte{0, 0} buf := bytes.NewBuffer(b) _, err := buf.Read(b2) if err != nil { panic(err) } // バッファからlen(p)サイズ文を読み取りpに格納する fmt.Println(string(b2)) } 実行すると12という結果が得られます。b2は2つの領域を定義しており、それが上書きされる挙動になっています。一方Writeの方は、</description></item><item><title>bazel触ってみた</title><link>https://lottotto.github.io/blog/posts/bazel/</link><pubDate>Mon, 10 Jan 2022 17:42:02 +0900</pubDate><guid>https://lottotto.github.io/blog/posts/bazel/</guid><description>bazelとは ソースコードをコンパイルして、実行可能形式にしたり、テストをしたりする一連の処理をまとめてやってくれるツールのことをビルドツールと言い、例えばMake,Maven, Gradleなどがある。 もともとgoogle ではBlazeというビルドツールが利用されていて、これをOSS化したのがbazelになる
bazelの特徴 多言語サポート
Bazelは多くの言語をサポートしており、任意のプログラミング言語をサポートするように拡張可能。 高レベルのビルド言語
プロジェクトはBUILDファイルにてで記述。BUILDファイル相互接続された小さなライブラリ、バイナリ、およびテストのセットとしてプロジェクトを記述する簡潔なテキスト形式。対照的に、Makeのようなツールでは、個々のファイルとコンパイラの呼び出しを記述する必要があります。 マルチプラットフォームのサポート
同じツールと同じBUILDファイルを使用して、さまざまなアーキテクチャ、さらにはさまざまなプラットフォーム用のソフトウェアを構築可能 GoogleではBazelを使用してデータセンターのシステムで実行されるサーバーアプリケーションから携帯電話で実行されるクライアントアプリまで、あらゆるものを構築。 再現性
BUILDファイルでは、各ライブラリ、テスト、およびバイナリで直接の依存関係を完全に指定する必要があるため、Bazelはこの依存関係情報を使用して、ソースファイルに変更を加えたときに何を再構築する必要があるか、およびどのタスクを並行して実行できるかを認識。 これはすべてのビルドが常に同じ結果を生成することを意味します。 スケーラブル
Bazelは大規模なビルドを処理可能。 Googleでは、サーバーバイナリに10万のソースファイルがあるのが一般的であり、ファイルが変更されていないビルドには約200ミリ秒かかかるらしい Googleはなぜbazelを利用するのか Makeの場合 人力でMakefileを書くのは結構辛い Mavenの場合 Javaだけなのが辛い Bazelではコードを再利用可能な単位に細分化することを推奨しており、差分だけをビルドするといったことが可能なので gradleの場合 Gradleの設定ファイルが読みづらいのが辛い Bazelは各アクションが何を行うかを正確に理解できるのでより並列化され、より再現性が高くなるらしい gradle 陣営はbazelを使うとBUILDファイルがめちゃくちゃ増えることなどで管理コストが増大することを理由に反論しています 参考: https://blog.gradle.org/gradle-vs-bazel-jvm
対応言語やフレームワーク https://awesomebazel.com/ ほとんど一般的な言語やフレームワークは対応していそうですね。
実際にどのような会社やOSSがbazelを使用しているのか https://bazel.build/users.html に書いてあるが気になった部分を書きます。</description></item></channel></rss>