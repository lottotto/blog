<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Go on lottoHub</title><link>https://lottotto.github.io/blog/tags/go/</link><description>Recent content in Go on lottoHub</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 12 Feb 2022 13:25:22 +0900</lastBuildDate><atom:link href="https://lottotto.github.io/blog/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Opentelemetryで基本的なトレーシングパターンを実装する</title><link>https://lottotto.github.io/blog/posts/otelsql-grpc/</link><pubDate>Sat, 12 Feb 2022 13:25:22 +0900</pubDate><guid>https://lottotto.github.io/blog/posts/otelsql-grpc/</guid><description>モチベーション Go言語のOpentelemetryで適当なアプリにトレーシング機能をInstrumentation（計装）した際に、分割して色々なものは対応していたのだが、まとめてやってみたというものがなく、結構苦戦したので忘備録がてら残しておこうと思う。ソースコード全量はGithubにPushしているので面倒な解説はいらねえ！という人はこちらをみてください。 https://github.com/lottotto/gRPC-Database-sample-app/tree/7f4d8f91d0c5d5a675d49e18a058c470d9b34973
トレースしたいシステム クライアントからgRPC GateWayにhttpで送られたものがgRPC通信でgRPCサーバに転送。gRPCサーバがPostgresにSQLを実行する流れを確認したい。ただしフォーカスとしてはgRPC GateWayからとする。 クライアントからは/に対してbodyに{&amp;quot;name&amp;quot;: message} の形式のJSONをPostすることで、データベースにその内容がINSERTされる。またクエリパラメータにそのnameを付与してGETで送ることで、そのnameを持つ行全てを戻す。
実装のポイント クライアント側 標準ライブラリを用いたhttpサーバの構成方法は他の記事に譲るとして、、、
TraceProviderの追加 TracerProvider provides access to instrumentation Tracers. TracerProviderとはTracerへのアクセスを提供する。TracerとはStartメソッドを持つInterfaceであり、contextとNameを引数にSpanとContextを作成する機能を持つ。もしこのcontextの中にSpanがあればその子spanとして作成される
参考:
https://pkg.go.dev/go.opentelemetry.io/otel/trace#TracerProvider https://pkg.go.dev/go.opentelemetry.io/otel/trace#Tracer
TracerProviderへの追加はプロセスセーフではないといけないので、main関数の中でかくこと。間違ってもhandlerとか多数のスレッドで呼び出されるところでやってはいけない。 後続のサービスへspanのContextを伝播するには、otel.SetTextMapPropagatorを追記すること。これはリクエスト送る側だけではなく、受け取る側にも必要
package main import ( &amp;#34;github.com/lottotto/stdgrpc/utils&amp;#34; &amp;#34;go.opentelemetry.io/otel&amp;#34; &amp;#34;go.opentelemetry.io/otel/propagation&amp;#34; ) func main() { // トレースの追加 tp, err := utils.InitTraceProviderStdOut(&amp;#34;gRPC&amp;#34;, &amp;#34;1.0.0&amp;#34;) otel.SetTracerProvider(tp) // 後続のサービスにつなげるためにpropagaterを追加 otel.SetTextMapPropagator( propagation.NewCompositeTextMapPropagator( propagation.TraceContext{}, propagation.Baggage{}, ), ) .... } gRPCインターセプタの追加 gRPCで後続のサービスにリクエストを送るので、gRPCのインターセプタを利用して、gRPCの情報などをtraceの値に入れる。もちろん後続へspanを教えるためにこのメソッドは必要。 grpc.WithUnaryInterceptorを利用し、opentelemetryのUnary通信用のインターセプタを入れる。複数Interceptorを入れる場合はChain何ちゃらを使うこと。 （おまけ）gRPCのコネクションをプールとして利用する場合は、Controllerなりの構造体を作成し、その中にgRPCのconnectionを入れるのが良い。global変数として使うと、変数定義時に死ぬ。
package main import ( ... &amp;#34;go.</description></item><item><title>go言語のbyte.bufferについて</title><link>https://lottotto.github.io/blog/posts/go-bytebuffer/</link><pubDate>Sat, 29 Jan 2022 17:20:36 +0900</pubDate><guid>https://lottotto.github.io/blog/posts/go-bytebuffer/</guid><description>モチベーション Goの受け取ったデータを読んだり書いたりうまくできているのは、ReadメソッドとWriteメソッド、そしてどのメソッドを持つ、io.Reader、io.Writerといったインターフェースである。bytes.bufferをお題に色々忘れないようにメモしていく
byteとは 1バイトの範囲（1から255）を表すデータ型。 Go言語では、ファイル処理だったり、画像だったり、リクエストだったり色々な面で[]byteが出てくる。 もちろんstringも文字コードで表現されることから2バイトであるので、bytes型のスライスとして表現されることは多い。 []byteとstringの変換は下記の通り
// []bytes -&amp;gt; string の変換 str := string([]bytes) // string -&amp;gt; []bytesの変換 b := []byte(str) このようにbyte型のスライスは頻出で簡単にstringに変換できる。このbyte型のスライスを色々簡単に操作できるようなパッケージがbytesパッケージになる。詳しくは公式ドキュメント参照。https://pkg.go.dev/byte
bytesパッケージの中で2つだけ型が宣言されている.bytes.buffer型とreader型である。これをみていく
bytes.bufferとは bytes.bufferとは、readメソッドとwriteメソッドを持つ可変サイズのバイトバッファーです。 色々おさらいしていきます。bufferとは基本的には、データを一時的に記憶する場所のことを言います。なのでその一時保存領域を読んだり、一時領域に書いたりすることができるわけです。
// バッファからlen(p)サイズ文を読み取りpに格納する package main import ( &amp;#34;bytes&amp;#34; &amp;#34;fmt&amp;#34; ) func main() { str := &amp;#34;123456789&amp;#34; b := []byte(str) fmt.Println(b) b2 := []byte{0, 0} buf := bytes.NewBuffer(b) _, err := buf.Read(b2) if err != nil { panic(err) } // バッファからlen(p)サイズ文を読み取りpに格納する fmt.Println(string(b2)) } 実行すると12という結果が得られます。b2は2つの領域を定義しており、それが上書きされる挙動になっています。一方Writeの方は、</description></item></channel></rss>