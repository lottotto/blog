<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on lottoHub</title><link>https://lottotto.github.io/blog/posts/</link><description>Recent content in Posts on lottoHub</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 12 Feb 2022 13:25:22 +0900</lastBuildDate><atom:link href="https://lottotto.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Opentelemetryで基本的なトレーシングパターンを実装する</title><link>https://lottotto.github.io/blog/posts/otelsql-grpc/</link><pubDate>Sat, 12 Feb 2022 13:25:22 +0900</pubDate><guid>https://lottotto.github.io/blog/posts/otelsql-grpc/</guid><description>モチベーション Go言語のOpentelemetryで適当なアプリにトレーシング機能をInstrumentation（計装）した際に、分割して色々なものは対応していたのだが、まとめてやってみたというものがなく、結構苦戦したので忘備録がてら残しておこうと思う。ソースコード全量はGithubにPushしているので面倒な解説はいらねえ！という人はこちらをみてください。 https://github.com/lottotto/gRPC-Database-sample-app/tree/7f4d8f91d0c5d5a675d49e18a058c470d9b34973
トレースしたいシステム クライアントからgRPC GateWayにhttpで送られたものがgRPC通信でgRPCサーバに転送。gRPCサーバがPostgresにSQLを実行する流れを確認したい。ただしフォーカスとしてはgRPC GateWayからとする。 クライアントからは/に対してbodyに{&amp;quot;name&amp;quot;: message} の形式のJSONをPostすることで、データベースにその内容がINSERTされる。またクエリパラメータにそのnameを付与してGETで送ることで、そのnameを持つ行全てを戻す。
実装のポイント クライアント側 標準ライブラリを用いたhttpサーバの構成方法は他の記事に譲るとして、、、
TraceProviderの追加 TracerProvider provides access to instrumentation Tracers. TracerProviderとはTracerへのアクセスを提供する。TracerとはStartメソッドを持つInterfaceであり、contextとNameを引数にSpanとContextを作成する機能を持つ。もしこのcontextの中にSpanがあればその子spanとして作成される
参考:
https://pkg.go.dev/go.opentelemetry.io/otel/trace#TracerProvider https://pkg.go.dev/go.opentelemetry.io/otel/trace#Tracer
TracerProviderへの追加はプロセスセーフではないといけないので、main関数の中でかくこと。間違ってもhandlerとか多数のスレッドで呼び出されるところでやってはいけない。 後続のサービスへspanのContextを伝播するには、otel.SetTextMapPropagatorを追記すること。これはリクエスト送る側だけではなく、受け取る側にも必要
package main import ( &amp;#34;github.com/lottotto/stdgrpc/utils&amp;#34; &amp;#34;go.opentelemetry.io/otel&amp;#34; &amp;#34;go.opentelemetry.io/otel/propagation&amp;#34; ) func main() { // トレースの追加 tp, err := utils.InitTraceProviderStdOut(&amp;#34;gRPC&amp;#34;, &amp;#34;1.0.0&amp;#34;) otel.SetTracerProvider(tp) // 後続のサービスにつなげるためにpropagaterを追加 otel.SetTextMapPropagator( propagation.NewCompositeTextMapPropagator( propagation.TraceContext{}, propagation.Baggage{}, ), ) .... } gRPCインターセプタの追加 gRPCで後続のサービスにリクエストを送るので、gRPCのインターセプタを利用して、gRPCの情報などをtraceの値に入れる。もちろん後続へspanを教えるためにこのメソッドは必要。 grpc.WithUnaryInterceptorを利用し、opentelemetryのUnary通信用のインターセプタを入れる。複数Interceptorを入れる場合はChain何ちゃらを使うこと。 （おまけ）gRPCのコネクションをプールとして利用する場合は、Controllerなりの構造体を作成し、その中にgRPCのconnectionを入れるのが良い。global変数として使うと、変数定義時に死ぬ。
package main import ( ... &amp;#34;go.</description></item><item><title>go言語のbyte.bufferについて</title><link>https://lottotto.github.io/blog/posts/go-bytebuffer/</link><pubDate>Sat, 29 Jan 2022 17:20:36 +0900</pubDate><guid>https://lottotto.github.io/blog/posts/go-bytebuffer/</guid><description>モチベーション Goの受け取ったデータを読んだり書いたりうまくできているのは、ReadメソッドとWriteメソッド、そしてどのメソッドを持つ、io.Reader、io.Writerといったインターフェースである。bytes.bufferをお題に色々忘れないようにメモしていく
byteとは 1バイトの範囲（1から255）を表すデータ型。 Go言語では、ファイル処理だったり、画像だったり、リクエストだったり色々な面で[]byteが出てくる。 もちろんstringも文字コードで表現されることから2バイトであるので、bytes型のスライスとして表現されることは多い。 []byteとstringの変換は下記の通り
// []bytes -&amp;gt; string の変換 str := string([]bytes) // string -&amp;gt; []bytesの変換 b := []byte(str) このようにbyte型のスライスは頻出で簡単にstringに変換できる。このbyte型のスライスを色々簡単に操作できるようなパッケージがbytesパッケージになる。詳しくは公式ドキュメント参照。https://pkg.go.dev/byte
bytesパッケージの中で2つだけ型が宣言されている.bytes.buffer型とreader型である。これをみていく
bytes.bufferとは bytes.bufferとは、readメソッドとwriteメソッドを持つ可変サイズのバイトバッファーです。 色々おさらいしていきます。bufferとは基本的には、データを一時的に記憶する場所のことを言います。なのでその一時保存領域を読んだり、一時領域に書いたりすることができるわけです。
// バッファからlen(p)サイズ文を読み取りpに格納する package main import ( &amp;#34;bytes&amp;#34; &amp;#34;fmt&amp;#34; ) func main() { str := &amp;#34;123456789&amp;#34; b := []byte(str) fmt.Println(b) b2 := []byte{0, 0} buf := bytes.NewBuffer(b) _, err := buf.Read(b2) if err != nil { panic(err) } // バッファからlen(p)サイズ文を読み取りpに格納する fmt.Println(string(b2)) } 実行すると12という結果が得られます。b2は2つの領域を定義しており、それが上書きされる挙動になっています。一方Writeの方は、</description></item><item><title>bazel触ってみた</title><link>https://lottotto.github.io/blog/posts/bazel/</link><pubDate>Mon, 10 Jan 2022 17:42:02 +0900</pubDate><guid>https://lottotto.github.io/blog/posts/bazel/</guid><description>bazelとは ソースコードをコンパイルして、実行可能形式にしたり、テストをしたりする一連の処理をまとめてやってくれるツールのことをビルドツールと言い、例えばMake,Maven, Gradleなどがある。 もともとgoogle ではBlazeというビルドツールが利用されていて、これをOSS化したのがbazelになる
bazelの特徴 多言語サポート
Bazelは多くの言語をサポートしており、任意のプログラミング言語をサポートするように拡張可能。 高レベルのビルド言語
プロジェクトはBUILDファイルにてで記述。BUILDファイル相互接続された小さなライブラリ、バイナリ、およびテストのセットとしてプロジェクトを記述する簡潔なテキスト形式。対照的に、Makeのようなツールでは、個々のファイルとコンパイラの呼び出しを記述する必要があります。 マルチプラットフォームのサポート
同じツールと同じBUILDファイルを使用して、さまざまなアーキテクチャ、さらにはさまざまなプラットフォーム用のソフトウェアを構築可能 GoogleではBazelを使用してデータセンターのシステムで実行されるサーバーアプリケーションから携帯電話で実行されるクライアントアプリまで、あらゆるものを構築。 再現性
BUILDファイルでは、各ライブラリ、テスト、およびバイナリで直接の依存関係を完全に指定する必要があるため、Bazelはこの依存関係情報を使用して、ソースファイルに変更を加えたときに何を再構築する必要があるか、およびどのタスクを並行して実行できるかを認識。 これはすべてのビルドが常に同じ結果を生成することを意味します。 スケーラブル
Bazelは大規模なビルドを処理可能。 Googleでは、サーバーバイナリに10万のソースファイルがあるのが一般的であり、ファイルが変更されていないビルドには約200ミリ秒かかかるらしい Googleはなぜbazelを利用するのか Makeの場合 人力でMakefileを書くのは結構辛い Mavenの場合 Javaだけなのが辛い Bazelではコードを再利用可能な単位に細分化することを推奨しており、差分だけをビルドするといったことが可能なので gradleの場合 Gradleの設定ファイルが読みづらいのが辛い Bazelは各アクションが何を行うかを正確に理解できるのでより並列化され、より再現性が高くなるらしい gradle 陣営はbazelを使うとBUILDファイルがめちゃくちゃ増えることなどで管理コストが増大することを理由に反論しています 参考: https://blog.gradle.org/gradle-vs-bazel-jvm
対応言語やフレームワーク https://awesomebazel.com/ ほとんど一般的な言語やフレームワークは対応していそうですね。
実際にどのような会社やOSSがbazelを使用しているのか https://bazel.build/users.html に書いてあるが気になった部分を書きます。</description></item></channel></rss>